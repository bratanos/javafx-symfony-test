package com.innertrack.dao;

import com.innertrack.model.User;
import com.innertrack.util.DBConnection;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class UserDaoTest {

    private Connection connection;
    private UserDao userDao;

    @BeforeEach
    void setUp() throws SQLException {
        connection = DBConnection.getInstance().getConnection();


        connection.setAutoCommit(false);

        // 3. Initialize UserDao with our transactional connection
        userDao = new UserDao(connection);
    }

    @AfterEach
    void tearDown() throws SQLException {
        // 4. Rollback the transaction.
        // This undoes any inserts/updates/deletes done during the test.
        if (connection != null && !connection.isClosed()) {
            connection.rollback();
            connection.setAutoCommit(true); // Reset to default
        }
    }

    @Test
    void testCreateAndFind() throws SQLException {
        User user = new User();
        String uniqueEmail = "junit_create_" + System.currentTimeMillis() + "@test.com";
        user.setEmail(uniqueEmail);
        user.setPassword("secret123");
        user.setRoles(Arrays.asList("ROLE_USER"));
        user.setVerified(true);
        user.setStatus("active");

        // Test Create
        boolean created = userDao.create(user);
        assertTrue(created, "User should be successfully created in the DB");

        // Test Find to verify insertion
        User fetchedUser = userDao.findByEmail(uniqueEmail);
        assertNotNull(fetchedUser, "Should find the user we just created");
        assertEquals(uniqueEmail, fetchedUser.getEmail());
        assertEquals("active", fetchedUser.getStatus());
        assertTrue(fetchedUser.getRoles().contains("ROLE_USER"));
    }

    @Test
    void testUpdateUser() throws SQLException {
        // First create a user
        User user = new User();
        String uniqueEmail = "junit_update_" + System.currentTimeMillis() + "@test.com";
        user.setEmail(uniqueEmail);
        user.setPassword("pass");
        user.setRoles(Arrays.asList("ROLE_USER"));
        user.setVerified(false);
        user.setStatus("pending");
        userDao.create(user);

        // Retrieve to get the ID generated by DB
        User originalUser = userDao.findByEmail(uniqueEmail);
        assertNotNull(originalUser);
        int userId = originalUser.getId();

        // Modify fields
        originalUser.setStatus("banned");
        originalUser.setVerified(true);

        // Perform Update
        boolean updated = userDao.update(originalUser);
        assertTrue(updated, "Update should return true");

        // Verify changes
        User updatedUser = userDao.read(userId);
        assertNotNull(updatedUser);
        assertEquals("banned", updatedUser.getStatus());
        assertTrue(updatedUser.isVerified());
    }

    @Test
    void testDeleteUser() throws SQLException {
        // Create user
        User user = new User();
        String uniqueEmail = "junit_delete_" + System.currentTimeMillis() + "@test.com";
        user.setEmail(uniqueEmail);
        user.setPassword("pass");
        user.setRoles(Arrays.asList("ROLE_USER"));
        user.setVerified(true);
        user.setStatus("active");
        userDao.create(user);

        User savedUser = userDao.findByEmail(uniqueEmail);
        assertNotNull(savedUser);

        // Delete
        boolean deleted = userDao.delete(savedUser.getId());
        assertTrue(deleted, "Delete should return true");

        // Verify it's gone
        User deletedUser = userDao.read(savedUser.getId());
        assertNull(deletedUser, "User should no longer exist");
    }

    @Test
    void testFindAll() throws SQLException {
        // This test is tricky on a live DB because other data exists.
        // We just verify it doesn't crash and returns a list.
        List<User> users = userDao.findAll();
        assertNotNull(users);
        // We can't assert size because the DB might have pre-existing data
        // asking only if it's not null is safer.
    }
}
